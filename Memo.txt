빌드build: 소스코드파일오부터 최종적으로 실행파일을 만들어내는 과정
	전처리 preprocess
	컴파일 compile 소스파일을 목적파일로 변환하는 과정	<-- compiler
	링크 link	<-- linker



함수 정의부도 코드 메모리에 있는 것이다.
함수 호출이라는 것은 함수 정의부에 시작지점으로 가서 함수 정의부의 명령문을 실행하는 것이다
함수 호출에서 함수의 이름은 함수 정의부에 시작지점의 주소를 나타낸다

컴파일러는 주소값을 다루는 크기를 이미 알고있다.
그러므로 재귀함수의 정의를 만들어낼 수 있다.



structured programming
구조화 프로그래밍
: '함수'와 구조체 등의 '구조'물로 프로그램 구조를 만드는 방법


OOP Object Oriented Programming
객체 지향 프로그래밍
: 클래스 간 '관계', 객체 간 '관계'를 이용하여 프로그램 구조를 만드는 방법

추상화 abstraction
	데이터의 추상화 + 코드의 추상화 ---> 데이터의 추상화
	<-- 기능에 관련 제이터도 특서으로 함께 묶는다

은닉화 encapsulation
	멤버변수를 멤버함수 뒤로 감춘다
	<-- 클래스를 경계로 변경의 국지화를 이루기 위해서다.

------------------기본적인 객체의 요건

상속성 inheritance
	공통된 속성을 부모클래스에 두고
	자식 클래스는 이를 이어받아 작성한느 것
	<-- 코드의 효율적인 재사용

다형성 polymorphism
	같은 메시지에 다른 반응
	: 호출하는 측에 함수의 형태는 동일한데, 타입에 따라서 실제 동작이 다르다( 호출되는 함수의 종류가 다르다 )
	<-- 호출부의 코드를 일반화



수벡터 표기법
스칼라의 순서쌍으로 표기한다.
이를테면 다음과 같다
(1, 0)
이것은
	크기는 1
	방향은 (1, 0)

기하벡터
화살표로 표기한다
	화살표의 머리 부분이 자향하는 것이 방향이고
	화살표의 길이가 크기다.



벡터의 연산

i) 벡터끼리의 덧셈(뺄셈)

	각각의 구성성분끼리 더한다


ii) 벡터의 스칼라곱셈

	스칼라를 벡터의 각각의 구성성분에 곱한다


iii) 벡터끼리의 곱셈

	가) 내적

	A . B = ||A|| ||B|| cosT

	나) 외적

		A x B = ||A|| ||B|| sinT U
		(U는 A와 B에 모두 수직인 단위벡터)

		A = (A.x, A.y, A.z)
		B = (B.x, B.y, B.z)


		i = (1, 0, 0)
		j = (0, 1, 0)
		k = (0, 0, 1)

		A x B = (A.y * B.z - A.z * B.y) * i + (A.z * B.x - A.x * B.z) * j + (A.x * B.y - A.y * B.x) * k


iv) 그 외

	가) 벡터의 크기: 두 점 사이의 거리 구하기, 벡터자기자신을 내적하여 제곱근을 구한다

	나) 벡터의 정규화
	벡터에 벡터의 크기분의 1을 스칼라곱셈한다



자료구조: 자료Data를 담아두는 구조물
배열: 동일한 타입의 원소를 '연속적'인 메모리 블럭
링크드 리스트: 노드가 데이터와 링크를 가지고
	각각의 링크에 의해 선형으로 '연결'된 자료구조
트리:1:N의 비선형 자료구조, 계층형 자료구조
이진트리:
	트리
	최대 자식노드 개수는 2개 이하
	Lt, Rt
이진 탐색 트리
	이진 트리
	중복된 값을 허용하지 않는다
	lt.subtree < root && rt.subtree > root
	서브트리도 이진 탐색 트리다.
<-- 탐색이 매우 용이해진다
해쉬테이블: 데이터가 곧 위치다.



1 + 1 = 2	수식
숫자로 만들어진 식

a + b = c	대수식
숫자대신 문자로 만들어진 식

a * x + b = 0	방정식
미지수의 해를 구하는 것이 목적인 대수식

y = a * x + b	함수




대수학 algebra: 대수식을 다루는 수학분야

기하학 geometry: 도형을 다루는 수학분야

좌표계 coordirate system: 물체의 위치를 지정하기 위한 시스템

데카르트 좌표계( 직교좌표계 ): 각각의 축이 직각으로 만난다


게임세계를 다루므로 연속적인 공간이 필요하다
그러므로 좌표계의 수단위는 실수다.

float	<-- 게임 프로그램은 부정확한 프로그램이다. 그러므로 float를 주로 사용한다
double


장면: 픽셀의 2차원 배열이다. 그러므로 불연속적인 공간이다.

그러므로 다루는 수 단위는 '정수'다.


래스터: 픽셀정보들의 선형적인 모음

래스터라이즈 rasterize


실수 단위의 세계의 기하구조를
정수 단위의 불연속적인 세계(screen)에 표시하기 위해서는
임의의 알고리즘이 필요하다.



속도 = 거리의 변화량 / 시간의 변화량

Vx = delta Sx / delta t

delta Sx = Vx * delta t

Sx[n] - Sx[n-1] = Vx * delta t

//현재 위치 = 이전 위치 + 속도 * 시간간격
Sx[n] = Sx[n-1] + Vx * delta t



주어진 성분은 다음과 같다
	입사벡터 P
	평면의 법선벡터 n

반사벡터 R은 다음과 같다

	R = A + B

A는 벡터이므로 크기와 방향으로 이루어진다

방향 n
크기

	입사각 T에 대해 cosT를 구하면 다음과 같다
	||A|| / ||-P|| = cosT
	그러므로
	||A|| = ||-P|| ||n|| cosT
		= -P . n


그러므로 A = (-P . n) * n

B는 B = P + A
그러므로
R = A + B = A + P + A = P + 2 * A
	= P + 2 * ((-P . n) * n)



P = P_0 + t * (P_1 - P_0)

여기서 P는 직선 위의 임의의 한 점
P_0은 시점
P_1은 종점
t는 매개변수고 0 <= t <= 1



상태 패턴의 목적
'상태와 상태의 대응되는 행동'을 캡슐화하여
'상태와 상태의 대응되는 행동'을 객체로 다루기 위함이다.


상태 패턴의 구현

i) 구체적인 상태 클래스와
상태소유클래스의 '관계'

직접적으로는 아무 관계도 맺고 있지 않다
즉, 디커플링(decoupling)되어 있다
<-- 결합도가 아주 낮다

ii) CScene 클래스와
구체적인 상태 클래스의 '관계'

상속관계를 맺고 있다. (강한 결합)
다만, CScene은 형태만 제공한다
즉, 상속관계보다는 약한 결합이다.
<-- 결합도가 낮다

iii) 그러므로 상태패턴은
상태에 대해
추가, 변경, 삭제의 요구사항이 있는 경우
에 '유연한 구조'를 갖는다

예를 들면, 상태를 추가하는 경우
CScene을 상속받은 새로운 상태 클래스를 하나 만들고
해당 클래스의 내용만 작성하면 되기 때문이다.
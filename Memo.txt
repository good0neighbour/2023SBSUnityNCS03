빌드build: 소스코드파일오부터 최종적으로 실행파일을 만들어내는 과정
	전처리 preprocess
	컴파일 compile 소스파일을 목적파일로 변환하는 과정	<-- compiler
	링크 link	<-- linker



함수 정의부도 코드 메모리에 있는 것이다.
함수 호출이라는 것은 함수 정의부에 시작지점으로 가서 함수 정의부의 명령문을 실행하는 것이다
함수 호출에서 함수의 이름은 함수 정의부에 시작지점의 주소를 나타낸다

컴파일러는 주소값을 다루는 크기를 이미 알고있다.
그러므로 재귀함수의 정의를 만들어낼 수 있다.



structured programming
구조화 프로그래밍
: '함수'와 구조체 등의 '구조'물로 프로그램 구조를 만드는 방법


OOP Object Oriented Programming
객체 지향 프로그래밍
: 클래스 간 '관계', 객체 간 '관계'를 이용하여 프로그램 구조를 만드는 방법

추상화 abstraction
	데이터의 추상화 + 코드의 추상화 ---> 데이터의 추상화
	<-- 기능에 관련 제이터도 특서으로 함께 묶는다

은닉화 encapsulation
	멤버변수를 멤버함수 뒤로 감춘다
	<-- 클래스를 경계로 변경의 국지화를 이루기 위해서다.

------------------기본적인 객체의 요건

상속성 inheritance
	공통된 속성을 부모클래스에 두고
	자식 클래스는 이를 이어받아 작성한느 것
	<-- 코드의 효율적인 재사용

다형성 polymorphism
	같은 메시지에 다른 반응
	: 호출하는 측에 함수의 형태는 동일한데, 타입에 따라서 실제 동작이 다르다( 호출되는 함수의 종류가 다르다 )
	<-- 호출부의 코드를 일반화



수벡터 표기법
스칼라의 순서쌍으로 표기한다.
이를테면 다음과 같다
(1, 0)
이것은
	크기는 1
	방향은 (1, 0)

기하벡터
화살표로 표기한다
	화살표의 머리 부분이 자향하는 것이 방향이고
	화살표의 길이가 크기다.



벡터의 연산

i) 벡터끼리의 덧셈(뺄셈)

	각각의 구성성분끼리 더한다


ii) 벡터의 스칼라곱셈

	스칼라를 벡터의 각각의 구성성분에 곱한다


iii) 벡터끼리의 곱셈

	가) 내적

	A . B = ||A|| ||B|| cosT

	나) 외적

		A x B = ||A|| ||B|| sinT U
		(U는 A와 B에 모두 수직인 단위벡터)

		A = (A.x, A.y, A.z)
		B = (B.x, B.y, B.z)


		i = (1, 0, 0)
		j = (0, 1, 0)
		k = (0, 0, 1)

		A x B = (A.y * B.z - A.z * B.y) * i + (A.z * B.x - A.x * B.z) * j + (A.x * B.y - A.y * B.x) * k


iv) 그 외

	가) 벡터의 크기: 두 점 사이의 거리 구하기, 벡터자기자신을 내적하여 제곱근을 구한다

	나) 벡터의 정규화
	벡터에 벡터의 크기분의 1을 스칼라곱셈한다



자료구조: 자료Data를 담아두는 구조물
배열: 동일한 타입의 원소를 '연속적'인 메모리 블럭
링크드 리스트: 노드가 데이터와 링크를 가지고
	각각의 링크에 의해 선형으로 '연결'된 자료구조
트리:1:N의 비선형 자료구조, 계층형 자료구조
이진트리:
	트리
	최대 자식노드 개수는 2개 이하
	Lt, Rt
이진 탐색 트리
	이진 트리
	중복된 값을 허용하지 않는다
	lt.subtree < root && rt.subtree > root
	서브트리도 이진 탐색 트리다.
<-- 탐색이 매우 용이해진다
해쉬테이블: 데이터가 곧 위치다.



1 + 1 = 2	수식
숫자로 만들어진 식

a + b = c	대수식
숫자대신 문자로 만들어진 식

a * x + b = 0	방정식
미지수의 해를 구하는 것이 목적인 대수식

y = a * x + b	함수




대수학 algebra: 대수식을 다루는 수학분야

기하학 geometry: 도형을 다루는 수학분야

좌표계 coordirate system: 물체의 위치를 지정하기 위한 시스템

데카르트 좌표계( 직교좌표계 ): 각각의 축이 직각으로 만난다


게임세계를 다루므로 연속적인 공간이 필요하다
그러므로 좌표계의 수단위는 실수다.

float	<-- 게임 프로그램은 부정확한 프로그램이다. 그러므로 float를 주로 사용한다
double


장면: 픽셀의 2차원 배열이다. 그러므로 불연속적인 공간이다.

그러므로 다루는 수 단위는 '정수'다.


래스터: 픽셀정보들의 선형적인 모음

래스터라이즈 rasterize


실수 단위의 세계의 기하구조를
정수 단위의 불연속적인 세계(screen)에 표시하기 위해서는
임의의 알고리즘이 필요하다.



속도 = 거리의 변화량 / 시간의 변화량

Vx = delta Sx / delta t

delta Sx = Vx * delta t

Sx[n] - Sx[n-1] = Vx * delta t

//현재 위치 = 이전 위치 + 속도 * 시간간격
Sx[n] = Sx[n-1] + Vx * delta t



주어진 성분은 다음과 같다
	입사벡터 P
	평면의 법선벡터 n

반사벡터 R은 다음과 같다

	R = A + B

A는 벡터이므로 크기와 방향으로 이루어진다

방향 n
크기

	입사각 T에 대해 cosT를 구하면 다음과 같다
	||A|| / ||-P|| = cosT
	그러므로
	||A|| = ||-P|| ||n|| cosT
		= -P . n


그러므로 A = (-P . n) * n

B는 B = P + A
그러므로
R = A + B = A + P + A = P + 2 * A
	= P + 2 * ((-P . n) * n)



P = P_0 + t * (P_1 - P_0)

여기서 P는 직선 위의 임의의 한 점
P_0은 시점
P_1은 종점
t는 매개변수고 0 <= t <= 1



상태 패턴의 목적
'상태와 상태의 대응되는 행동'을 캡슐화하여
'상태와 상태의 대응되는 행동'을 객체로 다루기 위함이다.


상태 패턴의 구현

i) 구체적인 상태 클래스와
상태소유클래스의 '관계'

직접적으로는 아무 관계도 맺고 있지 않다
즉, 디커플링(decoupling)되어 있다
<-- 결합도가 아주 낮다

ii) CScene 클래스와
구체적인 상태 클래스의 '관계'

상속관계를 맺고 있다. (강한 결합)
다만, CScene은 형태만 제공한다
즉, 상속관계보다는 약한 결합이다.
<-- 결합도가 낮다

iii) 그러므로 상태패턴은
상태에 대해
추가, 변경, 삭제의 요구사항이 있는 경우
에 '유연한 구조'를 갖는다

예를 들면, 상태를 추가하는 경우
CScene을 상속받은 새로운 상태 클래스를 하나 만들고
해당 클래스의 내용만 작성하면 되기 때문이다.



FSM FiniteState Machine
유한상태기계

	유한한 개수의 상태들로 이루어진 가상의 기계

FSM의 두 가지 주요 구성요소

	상태
	전이조건

상태 패턴의 목적

	상태와 상태에 대응되는 행동을 캡슐화하여
	객체(데이터)로서 다루기 위함이다.


i) 상태소유클래스인 Example과 구체적인 상태클래스의 관계

	직접적인 관계는 없다.
	즉, 디커플링decoupling되어있다.

	상태소유클래스인 Example은 CScene으로부터
	구체적인 상태를 다루는 방법의 형태를 제공받는다

ii) CScene클래스와 구체적인 상태 클래스의 관계

	CScene클래스는 순수한 추상클래스가
	이것은 형태만 제공한다

	그러므로 구체적인 상태 클래스와는 보다 약한 결합이다.

iii) i)과 ii)를 통해서
상태소유클래스는 구체적인 클래스를 알 필요가 없다

그러므로
만약에 예를 들어 임의의 상태를 추가해야 한다면
상태를 다루는 측의 코드는 변경이 없고
상태클래스를 추가하는 작업만으로 해당 작업이 완료된다.

즉, 상태의 추가, 변경, 삭제 작업에 보다 유연한 구조다.



여기서 L은 선분 위의 임의의 한 점
L0 시점
L1 종점
t 비율	0 <= t <= 1,
	정규화하여 다루는 이유는 모든 선분에 대해 일반화하기 위해서다.

직선의 벡터방정식
L = L0 + t * (L1 - L0)



[] 캡춰절: 외부변수를 캡춰
() 매개변수 리스트
{} 정의부



f = g + h

f: fitness

	현재위치에서 판단가능한 '최선'의 비용

g: goal

	시작위치에서부터 현재위치까지의 '실제' 비용

h: heuristics

	현재위치에서 목표위치까지의 '추정' 비용



STL의 세 가지 구성요소

컨테이너 container
	자료구조를 타입에 대해 일반화시켜 놓은 것

반복자 iterator
	컨테이너와 알고리즘과 함께 사용할 수 있는 일반화된 포인터 형식

알고리즘 algorithm
	알고리즘을 타입에 대해 일반화시켜 놓은 것



순회traverse : 모든 원소들을 중복없이 한 번씩 방문하는 것
스택, 큐는 동작명세가 정해져있는 자료구조다.
그러므로 순회동작은 불가능하다
그러므로 반복자도 정의가 불가능하다



선형대수학 linear algebra
	: 벡터와 행렬 등은 '선형'적인 특징을 가진다. 그래서 선형대수학에서 다루는 주요한 주제다.

	벡터vector: 크기와 방향을 아우르는 개념
	<--재수적으로 스칼라들을 나열한 것


	행렬matrix:행과 열로 구성된 격자 모양의 배열 안에 스칼라를 나열한 것


선형linear란 무엇인가?

추상대수학이라는 수학분야에서는 대수학에서 다루는 수를
연산의 성질에 따라
분류한다.

그런 분류 중에 '체field'라는 것이 있다.

	'체'는 다음과 같은 성질을 만족한다.

	이항연산에서 가정한다

	사칙연산에 대해 닫혀있다.

	덧셈에 대한 항등원이 존재한다
	덧셈에 대한 역원이 존재한다

	곱셈에 대한 항등원이 존재한다
	곱셈에 대한 역원이 존재한다

	덧셈에 대한 교환법칙이 성립한다.
	덧셈에 대한 결합법칙이 성립한다.

	곱셈에 대한 교환법칙이 성립한다.
	곱셈에 대한 결합법칙이 성립한다.

	분배법칙이 성립한다.

	'체'에 속하는 것을 '스칼라'라고 한다.

		그래서 '실수'는 '대수구조' 중에서 체field에 해당한다.
		그러므로 실수는 스칼라다


위에 전개한 내용을 살펴보면
+와 *로 식이 이루어지는 것이 대상이다.
이러한 식의 특징은
원인을 넣으면 결과가 나온다
가 확정적이다.

수학에서는 이러한 성질을
'선형linear'라고 한다.



선형대수학에서 주로 다루는 수학적구조물

	벡터, 행렬


i) 행렬matrix의 정의:

	행과 열로 구성된 격자 모양의 배열 안에 스칼라를 나열한 것


ii) 행렬이 컴퓨터 연산에서 중요한 이유

	가) 컴퓨터는 기본적으로 가산기(accumulator)의 집합으로 이루어져 있다.

		가산기: 더하기 장치(회로)

	그러므로 가장 잘하는 연산은 +, *(더하기의 반복)이다.
	그러므로 컴퓨터는 선형적인 연산에 적합하다.

	나) 배열(메모리의 특성을 그대로 반영하는 자료구조)로 표현되기 때문에 속도가 빠르다
	--> 대량의 데이터 처리에 적합하다
	<-- 행렬의 곱셈의 결합법칙도 작용한다


iii) 몇 가지 정의와 개념

정방행렬square matrix
행과 열의 개수가 같은 행렬
게임개발에 주로 사용된다.

대각성분 diagonal element
	i = j가 같은 element, 행과 열의 번호가 같은 요소


영행렬 zero matrix
	모든 요소가 0인 행렬
	<-- 행렬 덧셈의 항등원

대각행렬diagonal matrix
	대각성분을 제외한 모든 성분이 0

단위행렬 identity matrix

	대각성분이 모두 1인 대각행렬
	<-- 행렬의 곱셈의 항등원


	항등원:
		임의의 연산에서 자기자신이 나오게 하는 것
		예) 3 * (1) = 3	<-- 1은 곱셈의 항등원

	역원: 
		임의의 연산에서 항등원이 나오게 하는 것
		예) 3 * (1 / 3) = 1	<-- 1 / 3은 3의 역원


iv) 행렬의 연산

	가) 행렬끼리의 덧셈: 같은 형태의 행렬끼리만 가능, 각각의 성분끼리 더한다

	나) 행렬끼리의 곱셈: Mij = 시그마 Aik * Bkj




에셋, 게임오브젝트의 서로간의 상관관계는 유니티 에디터에서만 조작한다.( 탐색기에서 임의로 하지 않는다)
<-- 왜냐하면 유니티 에디터에서 수행해야만 서로간의 상관관계가 갱신되고 유지된다.
( 이러한 상관관계 등을 기억하고 있는 것은 meta파일이다. )




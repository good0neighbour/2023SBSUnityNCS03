빌드build: 소스코드파일오부터 최종적으로 실행파일을 만들어내는 과정
	전처리 preprocess
	컴파일 compile 소스파일을 목적파일로 변환하는 과정	<-- compiler
	링크 link	<-- linker



함수 정의부도 코드 메모리에 있는 것이다.
함수 호출이라는 것은 함수 정의부에 시작지점으로 가서 함수 정의부의 명령문을 실행하는 것이다
함수 호출에서 함수의 이름은 함수 정의부에 시작지점의 주소를 나타낸다

컴파일러는 주소값을 다루는 크기를 이미 알고있다.
그러므로 재귀함수의 정의를 만들어낼 수 있다.



structured programming
구조화 프로그래밍
: '함수'와 구조체 등의 '구조'물로 프로그램 구조를 만드는 방법


OOP Object Oriented Programming
객체 지향 프로그래밍
: 클래스 간 '관계', 객체 간 '관계'를 이용하여 프로그램 구조를 만드는 방법

추상화 abstraction
	데이터의 추상화 + 코드의 추상화 ---> 데이터의 추상화
	<-- 기능에 관련 제이터도 특서으로 함께 묶는다

은닉화 encapsulation
	멤버변수를 멤버함수 뒤로 감춘다
	<-- 클래스를 경계로 변경의 국지화를 이루기 위해서다.

------------------기본적인 객체의 요건

상속성 inheritance
	공통된 속성을 부모클래스에 두고
	자식 클래스는 이를 이어받아 작성한느 것
	<-- 코드의 효율적인 재사용

다형성 polymorphism
	같은 메시지에 다른 반응
	: 호출하는 측에 함수의 형태는 동일한데, 타입에 따라서 실제 동작이 다르다( 호출되는 함수의 종류가 다르다 )
	<-- 호출부의 코드를 일반화



수벡터 표기법
스칼라의 순서쌍으로 표기한다.
이를테면 다음과 같다
(1, 0)
이것은
	크기는 1
	방향은 (1, 0)

기하벡터
화살표로 표기한다
	화살표의 머리 부분이 자향하는 것이 방향이고
	화살표의 길이가 크기다.



벡터의 연산

i) 벡터끼리의 덧셈(뺄셈)

	각각의 구성성분끼리 더한다


ii) 벡터의 스칼라곱셈

	스칼라를 벡터의 각각의 구성성분에 곱한다


iii) 벡터끼리의 곱셈

	가) 내적

	A . B = ||A|| ||B|| cosT

	나) 외적

		A x B = ||A|| ||B|| sinT U
		(U는 A와 B에 모두 수직인 단위벡터)

		A = (A.x, A.y, A.z)
		B = (B.x, B.y, B.z)


		i = (1, 0, 0)
		j = (0, 1, 0)
		k = (0, 0, 1)

		A x B = (A.y * B.z - A.z * B.y) * i + (A.z * B.x - A.x * B.z) * j + (A.x * B.y - A.y * B.x) * k


iv) 그 외

	가) 벡터의 크기: 두 점 사이의 거리 구하기, 벡터자기자신을 내적하여 제곱근을 구한다

	나) 벡터의 정규화
	벡터에 벡터의 크기분의 1을 스칼라곱셈한다



자료구조: 자료Data를 담아두는 구조물
배열: 동일한 타입의 원소를 '연속적'인 메모리 블럭
링크드 리스트: 노드가 데이터와 링크를 가지고
	각각의 링크에 의해 선형으로 '연결'된 자료구조
트리:1:N의 비선형 자료구조, 계층형 자료구조
이진트리:
	트리
	최대 자식노드 개수는 2개 이하
	Lt, Rt
이진 탐색 트리
	이진 트리
	중복된 값을 허용하지 않는다
	lt.subtree < root && rt.subtree > root
	서브트리도 이진 탐색 트리다.
<-- 탐색이 매우 용이해진다
해쉬테이블: 데이터가 곧 위치다.



1 + 1 = 2	수식
숫자로 만들어진 식

a + b = c	대수식
숫자대신 문자로 만들어진 식

a * x + b = 0	방정식
미지수의 해를 구하는 것이 목적인 대수식

y = a * x + b	함수




대수학 algebra: 대수식을 다루는 수학분야

기하학 geometry: 도형을 다루는 수학분야

좌표계 coordirate system: 물체의 위치를 지정하기 위한 시스템

데카르트 좌표계( 직교좌표계 ): 각각의 축이 직각으로 만난다


게임세계를 다루므로 연속적인 공간이 필요하다
그러므로 좌표계의 수단위는 실수다.

float	<-- 게임 프로그램은 부정확한 프로그램이다. 그러므로 float를 주로 사용한다
double


장면: 픽셀의 2차원 배열이다. 그러므로 불연속적인 공간이다.

그러므로 다루는 수 단위는 '정수'다.


래스터: 픽셀정보들의 선형적인 모음

래스터라이즈 rasterize


실수 단위의 세계의 기하구조를
정수 단위의 불연속적인 세계(screen)에 표시하기 위해서는
임의의 알고리즘이 필요하다.



속도 = 거리의 변화량 / 시간의 변화량

Vx = delta Sx / delta t

delta Sx = Vx * delta t

Sx[n] - Sx[n-1] = Vx * delta t

//현재 위치 = 이전 위치 + 속도 * 시간간격
Sx[n] = Sx[n-1] + Vx * delta t



주어진 성분은 다음과 같다
	입사벡터 P
	평면의 법선벡터 n

반사벡터 R은 다음과 같다

	R = A + B

A는 벡터이므로 크기와 방향으로 이루어진다

방향 n
크기

	입사각 T에 대해 cosT를 구하면 다음과 같다
	||A|| / ||-P|| = cosT
	그러므로
	||A|| = ||-P|| ||n|| cosT
		= -P . n


그러므로 A = (-P . n) * n

B는 B = P + A
그러므로
R = A + B = A + P + A = P + 2 * A
	= P + 2 * ((-P . n) * n)



P = P_0 + t * (P_1 - P_0)

여기서 P는 직선 위의 임의의 한 점
P_0은 시점
P_1은 종점
t는 매개변수고 0 <= t <= 1



상태 패턴의 목적
'상태와 상태의 대응되는 행동'을 캡슐화하여
'상태와 상태의 대응되는 행동'을 객체로 다루기 위함이다.


상태 패턴의 구현

i) 구체적인 상태 클래스와
상태소유클래스의 '관계'

직접적으로는 아무 관계도 맺고 있지 않다
즉, 디커플링(decoupling)되어 있다
<-- 결합도가 아주 낮다

ii) CScene 클래스와
구체적인 상태 클래스의 '관계'

상속관계를 맺고 있다. (강한 결합)
다만, CScene은 형태만 제공한다
즉, 상속관계보다는 약한 결합이다.
<-- 결합도가 낮다

iii) 그러므로 상태패턴은
상태에 대해
추가, 변경, 삭제의 요구사항이 있는 경우
에 '유연한 구조'를 갖는다

예를 들면, 상태를 추가하는 경우
CScene을 상속받은 새로운 상태 클래스를 하나 만들고
해당 클래스의 내용만 작성하면 되기 때문이다.



FSM FiniteState Machine
유한상태기계

	유한한 개수의 상태들로 이루어진 가상의 기계

FSM의 두 가지 주요 구성요소

	상태
	전이조건

상태 패턴의 목적

	상태와 상태에 대응되는 행동을 캡슐화하여
	객체(데이터)로서 다루기 위함이다.


i) 상태소유클래스인 Example과 구체적인 상태클래스의 관계

	직접적인 관계는 없다.
	즉, 디커플링decoupling되어있다.

	상태소유클래스인 Example은 CScene으로부터
	구체적인 상태를 다루는 방법의 형태를 제공받는다

ii) CScene클래스와 구체적인 상태 클래스의 관계

	CScene클래스는 순수한 추상클래스가
	이것은 형태만 제공한다

	그러므로 구체적인 상태 클래스와는 보다 약한 결합이다.

iii) i)과 ii)를 통해서
상태소유클래스는 구체적인 클래스를 알 필요가 없다

그러므로
만약에 예를 들어 임의의 상태를 추가해야 한다면
상태를 다루는 측의 코드는 변경이 없고
상태클래스를 추가하는 작업만으로 해당 작업이 완료된다.

즉, 상태의 추가, 변경, 삭제 작업에 보다 유연한 구조다.



여기서 L은 선분 위의 임의의 한 점
L0 시점
L1 종점
t 비율	0 <= t <= 1,
	정규화하여 다루는 이유는 모든 선분에 대해 일반화하기 위해서다.

직선의 벡터방정식
L = L0 + t * (L1 - L0)



[] 캡춰절: 외부변수를 캡춰
() 매개변수 리스트
{} 정의부



f = g + h

f: fitness

	현재위치에서 판단가능한 '최선'의 비용

g: goal

	시작위치에서부터 현재위치까지의 '실제' 비용

h: heuristics

	현재위치에서 목표위치까지의 '추정' 비용



STL의 세 가지 구성요소

컨테이너 container
	자료구조를 타입에 대해 일반화시켜 놓은 것

반복자 iterator
	컨테이너와 알고리즘과 함께 사용할 수 있는 일반화된 포인터 형식

알고리즘 algorithm
	알고리즘을 타입에 대해 일반화시켜 놓은 것



순회traverse : 모든 원소들을 중복없이 한 번씩 방문하는 것
스택, 큐는 동작명세가 정해져있는 자료구조다.
그러므로 순회동작은 불가능하다
그러므로 반복자도 정의가 불가능하다



선형대수학 linear algebra
	: 벡터와 행렬 등은 '선형'적인 특징을 가진다. 그래서 선형대수학에서 다루는 주요한 주제다.

	벡터vector: 크기와 방향을 아우르는 개념
	<--재수적으로 스칼라들을 나열한 것


	행렬matrix:행과 열로 구성된 격자 모양의 배열 안에 스칼라를 나열한 것


선형linear란 무엇인가?

추상대수학이라는 수학분야에서는 대수학에서 다루는 수를
연산의 성질에 따라
분류한다.

그런 분류 중에 '체field'라는 것이 있다.

	'체'는 다음과 같은 성질을 만족한다.

	이항연산에서 가정한다

	사칙연산에 대해 닫혀있다.

	덧셈에 대한 항등원이 존재한다
	덧셈에 대한 역원이 존재한다

	곱셈에 대한 항등원이 존재한다
	곱셈에 대한 역원이 존재한다

	덧셈에 대한 교환법칙이 성립한다.
	덧셈에 대한 결합법칙이 성립한다.

	곱셈에 대한 교환법칙이 성립한다.
	곱셈에 대한 결합법칙이 성립한다.

	분배법칙이 성립한다.

	'체'에 속하는 것을 '스칼라'라고 한다.

		그래서 '실수'는 '대수구조' 중에서 체field에 해당한다.
		그러므로 실수는 스칼라다


위에 전개한 내용을 살펴보면
+와 *로 식이 이루어지는 것이 대상이다.
이러한 식의 특징은
원인을 넣으면 결과가 나온다
가 확정적이다.

수학에서는 이러한 성질을
'선형linear'라고 한다.



선형대수학에서 주로 다루는 수학적구조물

	벡터, 행렬


i) 행렬matrix의 정의:

	행과 열로 구성된 격자 모양의 배열 안에 스칼라를 나열한 것


ii) 행렬이 컴퓨터 연산에서 중요한 이유

	가) 컴퓨터는 기본적으로 가산기(accumulator)의 집합으로 이루어져 있다.

		가산기: 더하기 장치(회로)

	그러므로 가장 잘하는 연산은 +, *(더하기의 반복)이다.
	그러므로 컴퓨터는 선형적인 연산에 적합하다.

	나) 배열(메모리의 특성을 그대로 반영하는 자료구조)로 표현되기 때문에 속도가 빠르다
	--> 대량의 데이터 처리에 적합하다
	<-- 행렬의 곱셈의 결합법칙도 작용한다


iii) 몇 가지 정의와 개념

정방행렬square matrix
행과 열의 개수가 같은 행렬
게임개발에 주로 사용된다.

대각성분 diagonal element
	i = j가 같은 element, 행과 열의 번호가 같은 요소


영행렬 zero matrix
	모든 요소가 0인 행렬
	<-- 행렬 덧셈의 항등원

대각행렬diagonal matrix
	대각성분을 제외한 모든 성분이 0

단위행렬 identity matrix

	대각성분이 모두 1인 대각행렬
	<-- 행렬의 곱셈의 항등원


	항등원:
		임의의 연산에서 자기자신이 나오게 하는 것
		예) 3 * (1) = 3	<-- 1은 곱셈의 항등원

	역원: 
		임의의 연산에서 항등원이 나오게 하는 것
		예) 3 * (1 / 3) = 1	<-- 1 / 3은 3의 역원

행벡터: 행으로만 이루어진 행렬. 벡터에 대응되므로 행벡터라 한다.

열벡터: 열로만 이루어진 행렬. 벡터에 대응되므로 행벡터라 한다.

iv) 행렬의 연산

	가) 행렬끼리의 덧셈: 같은 형태의 행렬끼리만 가능, 각각의 성분끼리 더한다

	나) 행렬끼리의 곱셈: Mij = 시그마 Aik * Bkj

	교환법칙은 성립하지 않는다
	결합법칙은 성립한다. (AB)C = A(BC)

	다) 전치 Transpose
		i행 j열의 요소를 j행 i열의 요소로 바꾼다
		( 정방행렬에서는 대각성분을 기준으로 뒤바꾼다 )

	라) 행렬식 determinent
		임의의 행렬에 대응되는 스칼라 평가값을 얻는 식이다.
		<-- 행렬의 특성을 알게 해준다.
		<--<-- 대표적인 가역인지 여부를 판단할 수 있게 해준다.

		정방행렬에서만 구할 수 있다.

		'여인수 전개 방법'으로 n * n행렬의 행렬식을 구할 수 있다.
			i) 만만한 행 또는 열을 하나 선택한다(0이나 1이 많은 것)
			ii) 선택한 행 또는 열에 스칼라를 계수로 적는다
			iii) 부호규칙을 적용한다
			iv) 여인수를 적용한다


	마) 역행렬 inverse matrix
		행렬 곱셈에 대한 역원

		임의의 행렬 A에 대해
		A의 역행렬 A^-1는 다음과 같이 구한다


		A^-1 = (1 / detA) * adjA

			adjA ( 수반행렬 )는 다음과 같이 구한다
			1) 전치한다
			2) 여인수행렬을 구한다


	바) 행렬의 스칼라곱셈
		행렬의 각각의 원소에 스칼라를 곱한다.




에셋, 게임오브젝트의 서로간의 상관관계는 유니티 에디터에서만 조작한다.( 탐색기에서 임의로 하지 않는다)
<-- 왜냐하면 유니티 에디터에서 수행해야만 서로간의 상관관계가 갱신되고 유지된다.
( 이러한 상관관계 등을 기억하고 있는 것은 meta파일이다. )



C++

	struct vs class

	접근제한 지정자의 기본 설정만 다르고
	나머지는 똑같다.


C++

	class CUnit
	{

	}


	CUnit tUnit;


	CUnit* tUnit = nullptr;
	tUnit = new CUnit();




미분(무한의 개념과 함께 잘게 쪼갠 것)

속도 = 거리의 변화 / 시간의 변화
가속도 = 속도의 변화 / 시간의 변화


Vx = dSx / dt
	Integral Vx dt = Integral dSx / dt dt
	Sx = Integral Vx dt
	Sx = Integral (Ax * t + C0) dt

	Sx = 0.5 * Ax * t^2 + C0 * t + C1


Ax = dVx / dt
	Integral Ax dt = Integral dVx / dt dt
	Vx = Integral Ax dt
	Vx = Ax * t + C0


x축 등가속도 운동

	Ax = 0
	Sx = 0.5 * Ax * t^2 + C0 * t + C1


y축 중력가속도 운동

	Ax = G
	Sy = 0.5 * Ay * t^2 +Cy0 * t + Cy1




플러드 필 알고리즘
: 폐쇄된 영역에 모든 칸을 채우는 알고리즘

<-- 원래는 색칠하기 알고리즘이었지만
속도가 느려서
색칠하기 알고리즘으로는 쓰이지 않고
응용하여 여타 게임 알고리즘들을 만든다.




통맵

	전체 맵을 1개(또는 몇 개)의 통이미지로 표현하는 방식

타일맵

	전체 맵을
	작은 이미지 단위의
	타일이라는 개념의
	조합으로 표현하는 방식


두 개념의 비교

	통맵

		i) 아트 측면에서 유려한 스래픽 표현이 가능하다. 자유롭다.
		ii) 반면에 맵 크기만한 이미지가 필요하므로 용량을 매우 많이 차지한다

	타일맵

		i) 아트 측면에서 이미지 단위의 조합으로 표현되므로 그래픽 품질이 조악해보일 수도 있다. 표현에 제약이 있다.
		ii) 반면에 이미지 단위들의 조합으로 속성값을 참고하여 표시하므로 용량이 매우 절약된다.

메모리가 절약되는 예시

예를 들면

전체맵 크기 400 * 400 pixel

스크린 크기 100 * 100 pixel


통맵 경우
	400 * 400 * 4byte = 640000byte

타일맵의 경우

	타일의 크기 50 * 50 pixel

	준비된 타일의 개수	2개
		2 * 50 * 50 * 4byte = 20000

	스크린에 표시되는 타일 개수	4개
		4 * 50 * 50 * 4byte = 40000

	전체맵을 표현하기 위한 속성맵의 원소 개수
	(속성은 int로 가정 ) 8 * 8

		8 * 8 * 4byte = 256

	60256 = 20000 + 40000 + 256

그러므로, 이 예시에서
타일맵이 통맵보다 579744바이트 이득이다.




A^-1: 임의의 행렬 A에 대한 역행렬
det A: 임의의 행렬 A에 대한 행렬식. 여인수 전개 방법으로 구할 수 있다.
adj A: 임의의 행렬 A에 대한 수반행렬.

	수반행렬 구하기
	i) 전치
	ii) 여인수행렬




f = g + h

A* 알고리즘에서
임의의 경로정보 노드의
비용 평가식


g goal		최초 시작지점에서 현재지점까지의 실제 비용
h heuristics	현재지점에서 최종 목적지점까지의 추정 비용
f fitness	현재지점에서 판단가능한 최선의 비용




Shading: 픽셀의 최종 색상 결정

Material: 재질: How to Shading
어떻게 셰이딩할지에 대한
데이터와 방법을 담은 에셋

Texture 텍스쳐: 이미지 데이터 + @

모델 파일 애셋

메쉬 mesh: 정점의 집합, 삼각형의 집합

import: 임의의 파일을 유니티 에디터로 가져와 '애셋asset'화 시키는 것

Aspect
종횡


유니티에서 길이 1은 1m에 대응된다




삼각형triangle
: 정점vertex 3개로 이루어진 도형이다.

--> 3디 그래픽스에서는
삼각형을 폴리곤(polygon)의 가장 기초적인 재료로 사용한다.

	<-- 삼각형을 재료로 사용하는 이유는
	삼각형의 정점 3개는
	항상 한 평면 위에 존재한다
	는 것이
	'수학적으로 보장'되기 때문이다.
		<-- 삼각형의 이웃한 임의의 두 변을 벡터로 보고 외적하면(외적의 오른손 법칙)
		이 벡터들은 모두 같은 방향을 가진다
		그리고 이것을 정규화하면 그것이
		정점 3개로 만들어진 평면의 법선벡터다.

메쉬mesh
	<--삼각형의 모음( 정점의 모음 )

투영 projection : N차원의 공간을 N-1차원으로 만드는 것

변환 Transformation: 자기자신으로의 사상(매핑, 대응)


렌더링 Rendering
	:3D 월드에 있는 '정점'단위의 물체를
	최종적으로
	2D 모니터의 '픽셀'단위의 프레임(이미지 데이터)으로
	만드는 것

렌더링 파이프라인 Rendering Pipeline
	: 렌더링의 단계별 공정의 집합

	다음은 일반적인 렌더링 파이프라인의 공정 분류다.

월드변환: 로컬좌표계 상의 정점의 위치 --> 월드 좌표계 상의 정점의 위치 변환 ( 월드좌표는 절대좌표 )
뷰변환: 카메라를 원점으로 삼았을 때 시야절두체 상에서 정점의 위치 변환
투영변환: 시야절두체로 만들어진 뷰볼륨(view volume)의 정점의 위치--> 정규 뷰 볼륨(경계가 1인 정육면체 공간)의 근평면의 정점의 위치로 변환

-----------------------------------------------------------------------------------------------------------------------
응용application단계				기하geometry단계			레스터라이즈rasterize 단계
-----------------------------------------------------------------------------------------------------------------------


응용프로그램에서		월드변환    뷰변환    투영변환    뷰포트변환
그래픽처리에 필요한
명령문과 데이터를		이동	    이동      3D->2D	  임의의 스크린 영역(viewport)
조직화하여			회전	    회전		  에 2D를 표시
'그래픽 처리장치'로		비례
넘긴다



-----------------------------------------------------------------------------------------------------------------------
CPU, RAM					GPU, Video RAM

						정점데이터를 다룬다			픽셀데이터를 다룬다
						연속적인 공간을 다룬다			불연속적인 공간을 다룬다


programmable rendering pipeline

shading: 픽셀의 최종 색상 결정 = 물체의 색상 + 텍스쳐 + 조명

shader: 작은 조각 프로그램. 랜더링 파이프라인의 임의의 단계에 부품으로 삽입할 수 있는 셰이딩 프로그램이다.

	vertex shader: 정점 단위의 데이터를 처리하는 셰이더
	pixel shader: 픽셀 단위의 데이터를 처리하는 셰이더

Materal: How To Shading. 어떻게 셰이딩할지에 대한 데이터와 방법을 담은 개념


원근 투영: perspective projection

	시야 절두체 view frustrum <-- 피라미드 모양에서 꼭대기를 잘라낸 것처럼 생긴 공간

직교 투영: orthographic projection

	시야 절두체 view frustrum <-- 직육면체 형태로 생긴 공간




i) struct는 값타입, class는 참조타입
ii) struct는 기본생성자를 명시적으로 가질 수 없다
iii) struct는 멤버변수 선언시 초기화 표현이 불가
iv) struct로 만든 것을 상속 불가




동차 좌표계: 수학에서 사영기하학에서 나오는 개념
	하지만 3D 그래픽스에서는 그 개념을 그대로 쓰는 게 아니라
	
	한 차원 높은 곳에 힘을 빌어
	현재 차원에서 필요한 개념을 설명할 때 쓴다




변환 과정에서 이루어지는
행렬의 연산을 곱셈으로 통일하기 위해
이동변환 행렬도
(덧셈으로 가능하기는 하지만 )
곱셈으로 만든다.




배열: 동일한 타입의 원소들의 연속적인 메모리 블럭
링크드리스트: 노드가 데이터와 링크를 가지고 각각의 링크에 의해 연결된 자료구조

트리: 1:n의 비선형구조, 계층형 자료구조
이진트리
	트리
	최대 2개까지의 자식노드
	lt, rt 자식노드

이진탐색트리
	이진트리
	중복된 값을 허용하지 않는다
	lt subtree의 값은 root보다 작고, rt subtree의 값은 root보다 크다

	서브트리도 이진탐색트리

해쉬테이블: 데이터가 곧 위치가 되는 자료구조




컨테이너 container: 자료구조를 타입을 일반화하여 범용적으로 만들어놓은 것
반복자 iterator: 컨테이너와 알고리즘과 함께 사용할 수 있게 설계된 일반화된 포인터 형식
알고리즘 algorism: 알고리즘을 타입을 일반화하여 범용적으로 만들어놓은 것




3D 공간 상에 정점 단위의 물체를
2D 모니터 상에 픽셀 단위의 프레임(이미지 데이터)으로 만드는 것




'행렬의 곱셈'으로 연산을 통일하기 위해서다.

i) 동차좌표계의 개념을 빌어 위치와 벡터를 구별하므로 열벡터는 4 * 1의 형태를 가진다.
행렬의 곱셈의 정의에 의해서
변환행렬은 n * 4의 크기를 가져야만 한다.

ii) 이동변환행렬을 행렬의 곱셈연산으로 만들면
4열의 1, 2, 3행을 오프셋 성분으로 채워야 한다.

iii) 투영변환행렬을 구성하려면 4열 부분과 4행 부분도 이용해야 한다.




Unity
pixel per unit
:1유닛에 몇개의 픽셀이 들어가는지에 대한 수치




스프라이트 리소스 제작 세 가지 정도의 종류

i) 프레임 당 파일로 제작
	<--프로그램에서 다루기 쉽다.
	<--파일 로드 연산이 들어간다

ii) N개의 프레임을 하나의 파일에 담아 제작
<-- 각각의 프레임의 너비, 높이를 일정하게 제작

	<--프로그램에서 다루기 어렵다.
	<--파일 로드의 연산이 i)보다는 매우 적다

iii) N개의 프레임을 하나의 파일에 담아 제작
<-- 각각의 프레임의 너비, 높이를 제각각으로 제작

	<--프로그램에서 다루기 더욱 어렵다.
	<--파일 로드의 연산이 i)보다는 매우 적다




Sprite Animation: frame by frame 애니메이션
: 일정 시간 간격으로 순차적으로 연속된 이미지를 보여주어 애니메이션을 만드는 것.




Sprite Sheet
: N개의 프레임이 하나의 파일로 만들어져 있는 스프라이트 파일

Atlas
: N개의 이미지가 집합되어 있는 하나의 파일




선형보간 linear interpolation
원래의 값을 구할 수 없어
일차 함수(직선의 방정식)를 이용하여 근사치를 구하는 것이다.
<-- 직선 상의 임의의 두 값의 사이에 있는 값을 일차함수를 이용하여 결정한다.




html: 웹문서의 포멧( 화면에 보이는 모양 )을 꾸며주기 위해 존재하는 Markup Language

css: html의 꾸며주기 기능의 단조로움을 보완하기 위해 만들어진 디자인용 언어

javascript: 웹 클라이언트 측에 상호작용이 필요한 기능을 만들기 위해 지원되는 프로그래밍 언어

xml: 원래는 html의 대체 용도로 만들어졌지만
	지금은 임의의 포멧을 사용자가 정의할 수 있는 도구로 발전되었다.

json: Java Script Object Notation
	원래는 javascript언어에서 오브젝트를 나타내는 문법 용도였는데
	지금은 임의의 포멧을 사용자가 정의할 수 있는 도구로 발전되었다.




UIToolkit

	html, xml	-->	uxml
	css		-->	uss	<-- uss를 바꾸면 디자인을 한방에 바꿀 수 있다.
	javascript	-->	C#

	uxml, uss <-- 사람이 눈으로 보고 편집가능하다

	UI Toolkit의 디자인 요소에
	데이터 드리븐 data driven 방식이 적용되어 있다.
	: 게임에 필요한 데이터를 사전에 미리 정의해두고 '파일' 형태로 만들어두는 것
		<-- 작업분담의 단위로 '파일'을 사용하기 위해서다.




파일 형태로 저장, 로드하는 형식은 다음 두 가지가 있다.

	text vs binary

	text
		장점
			사람이 눈으로 보고 편집가능하다
		단점
			같은 데이터라면 일반적으로 크기가 커진다

	binary
		장점
			같은 데이터라면 일반적으로 크기가 작아진다
		단점
			사람이 눈으로 보고 편집 불가다